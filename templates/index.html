<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>RTMP-RTSP Монитор</title>
    <link rel="icon" type="image/x-icon" href="/static/favicon.ico">
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/css/bootstrap.min.css" rel="stylesheet">
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/hls.js@1.4.12/dist/hls.min.js"></script>
    <style>
        /* ... existing styles ... */
        
        .stream-item {
            background-color: #ffffff;
            border: 1px solid #e0e0e0;
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 10px;
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            transition: all 0.3s ease;
        }

        .stream-item:hover {
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
        }

        .stream-info {
            flex: 1;
            margin-right: 15px;
        }

        .stream-info h3 {
            margin: 0 0 10px 0;
            font-size: 1.1em;
            color: #333;
        }

        .stream-info p {
            margin: 5px 0;
            font-size: 0.9em;
            color: #666;
        }

        .stream-actions {
            display: flex;
            gap: 8px;
            align-items: center;
        }

        .btn-action {
            padding: 6px 12px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.9em;
            display: flex;
            align-items: center;
            gap: 5px;
            transition: all 0.2s ease;
        }

        .btn-graph {
            background: #17a2b8;
            color: white;
            border: none;
        }

        .btn-graph:hover {
            background: #138496;
        }

        .btn-delete {
            background: #dc3545;
            color: white;
            border: none;
        }

        .btn-delete:hover {
            background: #c82333;
        }

        .btn-action i {
            font-size: 0.9em;
        }

        .status-active {
            color: #28a745;
        }

        .status-inactive {
            color: #dc3545;
        }

        .status-pending {
            color: #ffc107;
        }

        .drone-popup {
            min-width: 300px;
        }
        
        .video-container {
            margin-top: 10px;
            width: 100%;
            max-width: 320px;
            background: #000;
            border-radius: 4px;
            overflow: hidden;
            position: relative;
        }
        
        .drone-video {
            width: 100%;
            height: auto;
            display: block;
        }
        
        .video-loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            background: rgba(0, 0, 0, 0.7);
            padding: 10px 20px;
            border-radius: 4px;
            display: none;
        }
        
        .video-loading.active {
            display: block;
        }
        
        .video-container.loading::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.5);
        }
    </style>
</head>

{% extends "base.html" %}

{% block content %}
<div class="row mb-3">
    <div class="col-12">
        
        <button type="button" class="btn btn-success ms-2" data-bs-toggle="modal" data-bs-target="#rtmpSimulatorModal">
            <i class="fas fa-video"></i> RTMP Симулятор
        </button>
    </div>
</div>

<div class="row">
    <div class="col-md-8">
        <div class="card">
            <div class="card-header">
                <h5 class="card-title mb-0">
                    <i class="fas fa-map-marked-alt"></i> Карта дронов
                </h5>
            </div>
            <div class="card-body">
                <div id="map"></div>
            </div>
        </div>
    </div>
    <div class="col-md-4">
        <div class="card">
            <div class="card-header">
                <h5 class="card-title mb-0">
                    <i class="fas fa-video"></i> Активные потоки
                </h5>
            </div>
            <div class="card-body">
                <div id="streamsList"></div>
            </div>
        </div>
    </div>
</div>

<div class="row mt-4">
    <div class="col-12">
        <div class="card">
            <div class="card-header">
                <h5 class="card-title mb-0">
                    <i class="fas fa-chart-line"></i> Телеметрия
                </h5>
            </div>
            <div class="card-body">
                <canvas id="telemetry-chart"></canvas>
            </div>
        </div>
    </div>
</div>

<!-- Модальное окно симулятора RTMP -->
<div class="modal fade" id="rtmpSimulatorModal" tabindex="-1">
    <div class="modal-dialog modal-lg">
        <div class="modal-content">
            <div class="modal-header">
                <h5 class="modal-title">RTMP Симулятор</h5>
                <button type="button" class="btn-close" data-bs-dismiss="modal"></button>
            </div>
            <div class="modal-body">
                <div class="row">
                    <div class="col-md-6">
                        <div class="mb-3">
                            <label class="form-label">Предпросмотр</label>
                            <video id="previewVideo" class="w-100" autoplay muted controls></video>
                        </div>
                        <div class="mb-3">
                            <label class="form-label">RTMP URL</label>
                            <div class="input-group">
                                <input type="text" class="form-control" id="rtmpUrl" value="rtmp://localhost:1935/" readonly>
                                <button class="btn btn-outline-secondary" type="button" onclick="copyRtmpUrl(event)">
                                    <i class="fas fa-copy"></i>
                                </button>
                            </div>
                        </div>
                        <div class="mb-3">
                            <label class="form-label">Ключ потока</label>
                            <input type="text" class="form-control" id="streamKey" value="test_stream">
                        </div>
                    </div>
                    <div class="col-md-6">
                        <div class="mb-3">
                            <label class="form-label">Статус</label>
                            <div id="streamStatus" class="alert alert-info">Готов к трансляции</div>
                        </div>
                        <div class="mb-3" id="fileUploadSection">
                            <label class="form-label">Загрузить видеофайл</label>
                            <input type="file" class="form-control" id="videoFile" accept="video/*">
                        </div>
                    </div>
                </div>
            </div>
            <div class="modal-footer">
                <button type="button" class="btn btn-primary" id="startStreamBtn">Начать трансляцию</button>
                <button type="button" class="btn btn-danger" id="stopStreamBtn" style="display: none;">Остановить</button>
            </div>
        </div>
    </div>
</div>

<video id="hlsPlayer" controls></video>

<script>
let map;
let markers = {};
let telemetryChart;
let selectedDrone = null;
let lastStreams = {};

// RTMP Симулятор
let mediaRecorder;
let stream;
let wsConnection;
let videoFile = null;

// Инициализация карты
function initMap() {
    map = L.map('map').setView([43.238949, 76.889709], 13);
    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
        attribution: '© OpenStreetMap contributors'
    }).addTo(map);
}

// Обновление маркеров на карте
function updateMarkers(telemetry) {
    // Удаляем старые маркеры, которых больше нет в телеметрии
    for (const streamId in markers) {
        if (!telemetry[streamId]) {
            map.removeLayer(markers[streamId]);
            delete markers[streamId];
        }
    }

    for (const [streamId, data] of Object.entries(telemetry)) {
        const status = data.status || "inactive";
        let markerColor;
        
        switch(status) {
            case 'active':
                markerColor = '#28a745'; // зеленый
                break;
            case 'error':
                markerColor = '#dc3545'; // красный
                break;
            case 'pending':
                markerColor = '#ffc107'; // желтый
                break;
            default:
                markerColor = '#6c757d'; // серый
        }

        if (!markers[streamId]) {
            const droneIcon = L.divIcon({
                className: `drone-icon status-${status}`,
                html: `<div style="
                    width: 12px;
                    height: 12px;
                    background-color: ${markerColor};
                    border: 2px solid white;
                    border-radius: 50%;
                    box-shadow: 0 0 4px rgba(0,0,0,0.3);
                "></div>`,
                iconSize: [12, 12],
                iconAnchor: [6, 6],
                popupAnchor: [0, -6]
            });

            markers[streamId] = L.marker([data.latitude, data.longitude], {icon: droneIcon}).addTo(map);
            const popup = L.popup({
                closeButton: true,
                closeOnClick: false,
                autoClose: false
            }).setContent(`
                <div class="drone-popup">
                    <strong>Дрон: ${streamId}</strong><br>
                    Статус: <span class="status-${status}">${status}</span><br>
                    Высота: ${data.altitude !== undefined ? data.altitude.toFixed(1) + ' м' : 'N/A'}<br>
                    Скорость: ${data.speed !== undefined ? data.speed.toFixed(1) + ' м/с' : 'N/A'}<br>
                    Батарея: ${data.battery !== undefined ? data.battery.toFixed(1) + '%' : 'N/A'}<br>
                    Сигнал: ${data.signal_strength !== undefined ? data.signal_strength.toFixed(1) + '%' : 'N/A'}<br>
                    <div class="video-container">
                        <video id="video-${streamId}" class="drone-video" controls></video>
                        <div id="loading-${streamId}" class="video-loading">
                            <i class="fas fa-spinner fa-spin"></i> Загрузка видео...
                        </div>
                    </div>
                </div>
            `);
            
            markers[streamId].bindPopup(popup);
            
            // Инициализируем HLS для видео
            const videoElement = document.getElementById(`video-${streamId}`);
            const loadingElement = document.getElementById(`loading-${streamId}`);
            
            if (videoElement && loadingElement && Hls.isSupported()) {
                const videoContainer = loadingElement.parentElement;
                videoContainer.classList.add('loading');
                loadingElement.classList.add('active');
                
                const hls = new Hls({
                    debug: false,
                    enableWorker: true,
                    maxBufferLength: 60,
                    maxMaxBufferLength: 120,
                    maxBufferSize: 120 * 1000 * 1000,
                    maxBufferHole: 0.3,
                    highBufferWatchdogPeriod: 2,
                    nudgeMaxRetry: 5,
                    nudgeOffset: 0.1,
                    startFragPrefetch: true,
                    testBandwidth: true,
                    progressive: true,
                    lowLatencyMode: false,
                    backBufferLength: 60,
                    maxStarvationDelay: 2,
                    maxLoadingDelay: 2,
                    minAutoBitrate: 0,
                    abrEwmaDefaultEstimate: 500000,
                    abrBandWidthFactor: 0.95,
                    abrBandWidthUpFactor: 0.7,
                    abrMaxWithRealBitrate: true,
                    maxFragLookUpTolerance: 0.25,
                    startLevel: -1,
                    abrEwmaFastLive: 3.0,
                    abrEwmaSlowLive: 9.0,
                    manifestLoadPolicy: {
                        default: {
                            maxTimeToFirstByteMs: 10000,
                            maxLoadTimeMs: 20000,
                            timeoutRetry: {
                                maxNumRetry: 3,
                                retryDelayMs: 1000,
                                maxRetryDelayMs: 2000
                            },
                            errorRetry: {
                                maxNumRetry: 3,
                                retryDelayMs: 1000,
                                maxRetryDelayMs: 2000
                            }
                        }
                    },
                    playlistLoadPolicy: {
                        default: {
                            maxTimeToFirstByteMs: 10000,
                            maxLoadTimeMs: 20000,
                            timeoutRetry: {
                                maxNumRetry: 3,
                                retryDelayMs: 1000,
                                maxRetryDelayMs: 2000
                            },
                            errorRetry: {
                                maxNumRetry: 3,
                                retryDelayMs: 1000,
                                maxRetryDelayMs: 2000
                            }
                        }
                    },
                    fragLoadPolicy: {
                        default: {
                            maxTimeToFirstByteMs: 10000,
                            maxLoadTimeMs: 20000,
                            timeoutRetry: {
                                maxNumRetry: 3,
                                retryDelayMs: 1000,
                                maxRetryDelayMs: 2000
                            },
                            errorRetry: {
                                maxNumRetry: 3,
                                retryDelayMs: 1000,
                                maxRetryDelayMs: 2000
                            }
                        }
                    }
                });
                
                const hlsUrl = `http://localhost:8888/${streamId}/index.m3u8`;
                console.log('Загрузка HLS потока:', hlsUrl);
                
                let recoveryAttempts = 0;
                const MAX_RECOVERY_ATTEMPTS = 3;
                let lastErrorTime = 0;
                const ERROR_COOLDOWN = 5000; // 5 секунд между попытками восстановления
                
                hls.on(Hls.Events.ERROR, function(event, data) {
                    console.error('HLS ошибка:', data);
                    const now = Date.now();
                    
                    if (data.fatal) {
                        if (now - lastErrorTime < ERROR_COOLDOWN) {
                            console.log('Пропускаем восстановление из-за кулдауна');
                            return;
                        }
                        
                        lastErrorTime = now;
                        
                        switch(data.type) {
                            case Hls.ErrorTypes.NETWORK_ERROR:
                                console.error('Ошибка сети:', data);
                                if (recoveryAttempts < MAX_RECOVERY_ATTEMPTS) {
                                    recoveryAttempts++;
                                    loadingElement.innerText = `Ошибка сети, попытка восстановления ${recoveryAttempts}/${MAX_RECOVERY_ATTEMPTS}...`;
                                    setTimeout(() => {
                                        hls.startLoad();
                                    }, 1000);
                                } else {
                                    loadingElement.innerText = 'Не удалось восстановить соединение';
                                    hls.destroy();
                                }
                                break;
                            case Hls.ErrorTypes.MEDIA_ERROR:
                                console.error('Ошибка медиа:', data);
                                if (recoveryAttempts < MAX_RECOVERY_ATTEMPTS) {
                                    recoveryAttempts++;
                                    loadingElement.innerText = `Ошибка медиа, попытка восстановления ${recoveryAttempts}/${MAX_RECOVERY_ATTEMPTS}...`;
                                    setTimeout(() => {
                                        hls.recoverMediaError();
                                    }, 1000);
                                } else {
                                    loadingElement.innerText = 'Не удалось восстановить медиа';
                                    hls.destroy();
                                }
                                break;
                            default:
                                console.error('Фатальная ошибка:', data);
                                loadingElement.innerText = 'Ошибка загрузки потока';
                                hls.destroy();
                                break;
                        }
                    }
                });

                hls.on(Hls.Events.MANIFEST_LOADING, function() {
                    console.log('Загрузка HLS манифеста...');
                    loadingElement.innerText = 'Загрузка потока...';
                });

                hls.on(Hls.Events.MANIFEST_LOADED, function() {
                    console.log('HLS манифест загружен успешно');
                    recoveryAttempts = 0;
                });

                hls.on(Hls.Events.LEVEL_LOADED, function(event, data) {
                    console.log('Уровень качества загружен:', data);
                });

                hls.on(Hls.Events.FRAG_LOADED, function(event, data) {
                    console.log('Фрагмент загружен:', data);
                });

                hls.loadSource(hlsUrl);
                hls.attachMedia(videoElement);
                
                hls.on(Hls.Events.MANIFEST_PARSED, function() {
                    console.log('HLS манифест загружен');
                    videoElement.play().then(() => {
                        videoContainer.classList.remove('loading');
                        loadingElement.classList.remove('active');
                    }).catch(error => {
                        console.error('Ошибка воспроизведения:', error);
                        loadingElement.innerText = 'Ошибка воспроизведения';
                    });
                });
            }
            
            // Добавляем обработчик закрытия попапа
            markers[streamId].on('popupclose', function() {
                const video = document.getElementById(`video-${streamId}`);
                if (video) {
                    video.pause();
                    video.src = '';
                }
                if (markers[streamId].hls) {
                    markers[streamId].hls.destroy();
                    markers[streamId].hls = null;
                }
            });
            
            // Добавляем обработчик клика для выбора дрона и загрузки истории телеметрии
            markers[streamId].on('click', function() {
                selectDrone(streamId);
            });

        } else {
            // Обновляем позицию существующего маркера
            markers[streamId].setLatLng([data.latitude, data.longitude]);
            
            // Обновляем иконку, если статус изменился
            const currentIcon = markers[streamId].getIcon();
            if (!currentIcon.options.className.includes(`status-${status}`)) {
                const markerColor = status === 'active' ? '#28a745' : 
                                   status === 'error' ? '#dc3545' : 
                                   status === 'pending' ? '#ffc107' : '#6c757d';

                const newIcon = L.divIcon({
                    className: `drone-icon status-${status}`,
                    html: `<div style="
                        width: 12px;
                        height: 12px;
                        background-color: ${markerColor};
                        border: 2px solid white;
                        border-radius: 50%;
                        box-shadow: 0 0 4px rgba(0,0,0,0.3);
                    "></div>`,
                    iconSize: [12, 12],
                    iconAnchor: [6, 6],
                    popupAnchor: [0, -6]
                });
                markers[streamId].setIcon(newIcon);
            }
            
            // Обновляем содержимое попапа
            const popupContent = `
                <div class="drone-popup">
                    <strong>Дрон: ${streamId}</strong><br>
                    Высота: ${data.altitude !== undefined ? data.altitude.toFixed(1) + ' м' : 'N/A'}<br>
                    Скорость: ${data.speed !== undefined ? data.speed.toFixed(1) + ' м/с' : 'N/A'}<br>
                    Батарея: ${data.battery !== undefined ? data.battery.toFixed(1) + '%' : 'N/A'}<br>
                    Сигнал: ${data.signal_strength !== undefined ? data.signal_strength.toFixed(1) + '%' : 'N/A'}<br>
                    <div class="video-container">
                        <video id="video-${streamId}" class="drone-video" controls></video>
                        <div id="loading-${streamId}" class="video-loading">
                            <i class="fas fa-spinner fa-spin"></i> Загрузка видео...
                        </div>
                    </div>
                </div>
            `;
            
            // Проверяем, открыт ли попап
            const isPopupOpen = markers[streamId].getPopup().isOpen();
            markers[streamId].setPopupContent(popupContent);
            
            // Если попап был открыт, переинициализируем HLS
            if (isPopupOpen) {
                const videoElement = document.getElementById(`video-${streamId}`);
                const loadingElement = document.getElementById(`loading-${streamId}`);
                
                if (videoElement && loadingElement && Hls.isSupported()) {
                    const videoContainer = loadingElement.parentElement;
                    videoContainer.classList.add('loading');
                    loadingElement.classList.add('active');
                    
                    const hls = new Hls({
                        debug: false,
                        enableWorker: true,
                        maxBufferLength: 60,
                        maxMaxBufferLength: 120,
                        maxBufferSize: 120 * 1000 * 1000,
                        maxBufferHole: 0.3,
                        highBufferWatchdogPeriod: 2,
                        nudgeMaxRetry: 5,
                        nudgeOffset: 0.1,
                        startFragPrefetch: true,
                        testBandwidth: true,
                        progressive: true,
                        lowLatencyMode: false,
                        backBufferLength: 60,
                        maxStarvationDelay: 2,
                        maxLoadingDelay: 2,
                        minAutoBitrate: 0,
                        abrEwmaDefaultEstimate: 500000,
                        abrBandWidthFactor: 0.95,
                        abrBandWidthUpFactor: 0.7,
                        abrMaxWithRealBitrate: true,
                        maxFragLookUpTolerance: 0.25,
                        startLevel: -1,
                        abrEwmaFastLive: 3.0,
                        abrEwmaSlowLive: 9.0,
                        manifestLoadPolicy: {
                            default: {
                                maxTimeToFirstByteMs: 10000,
                                maxLoadTimeMs: 20000,
                                timeoutRetry: {
                                    maxNumRetry: 3,
                                    retryDelayMs: 1000,
                                    maxRetryDelayMs: 2000
                                },
                                errorRetry: {
                                    maxNumRetry: 3,
                                    retryDelayMs: 1000,
                                    maxRetryDelayMs: 2000
                                }
                            }
                        },
                        playlistLoadPolicy: {
                            default: {
                                maxTimeToFirstByteMs: 10000,
                                maxLoadTimeMs: 20000,
                                timeoutRetry: {
                                    maxNumRetry: 3,
                                    retryDelayMs: 1000,
                                    maxRetryDelayMs: 2000
                                },
                                errorRetry: {
                                    maxNumRetry: 3,
                                    retryDelayMs: 1000,
                                    maxRetryDelayMs: 2000
                                }
                            }
                        },
                        fragLoadPolicy: {
                            default: {
                                maxTimeToFirstByteMs: 10000,
                                maxLoadTimeMs: 20000,
                                timeoutRetry: {
                                    maxNumRetry: 3,
                                    retryDelayMs: 1000,
                                    maxRetryDelayMs: 2000
                                },
                                errorRetry: {
                                    maxNumRetry: 3,
                                    retryDelayMs: 1000,
                                    maxRetryDelayMs: 2000
                                }
                            }
                        }
                    });
                    
                    const hlsUrl = `http://localhost:8888/${streamId}/index.m3u8`;
                    console.log('Загрузка HLS потока:', hlsUrl);
                    hls.loadSource(hlsUrl);
                    hls.attachMedia(videoElement);
                    
                    hls.on(Hls.Events.MANIFEST_PARSED, function() {
                        console.log('HLS манифест загружен');
                        videoElement.play().then(() => {
                            videoContainer.classList.remove('loading');
                            loadingElement.classList.remove('active');
                        }).catch(error => {
                            console.error('Ошибка воспроизведения:', error);
                            loadingElement.innerText = 'Ошибка воспроизведения';
                        });
                    });

                    hls.on(Hls.Events.ERROR, function(event, data) {
                        console.error('HLS ошибка:', data);
                        if (data.fatal) {
                            switch(data.type) {
                                case Hls.ErrorTypes.NETWORK_ERROR:
                                    console.error('Ошибка сети:', data);
                                    loadingElement.innerText = 'Ошибка сети';
                                    hls.startLoad();
                                    break;
                                case Hls.ErrorTypes.MEDIA_ERROR:
                                    console.error('Ошибка медиа:', data);
                                    loadingElement.innerText = 'Ошибка медиа';
                                    hls.recoverMediaError();
                                    break;
                                default:
                                    console.error('Фатальная ошибка:', data);
                                    loadingElement.innerText = 'Ошибка загрузки потока';
                                    hls.destroy();
                                    break;
                            }
                        }
                    });

                    hls.on(Hls.Events.MANIFEST_LOADING, function() {
                        console.log('Загрузка HLS манифеста...');
                        loadingElement.innerText = 'Загрузка потока...';
                    });

                    hls.on(Hls.Events.MANIFEST_LOADED, function() {
                        console.log('HLS манифест загружен успешно');
                    });
                    
                    // Сохраняем ссылку на HLS инстанс
                    markers[streamId].hls = hls;
                }
            }
        }
    }
}

// Инициализация графика телеметрии
function initTelemetryChart() {
    const ctx = document.getElementById('telemetry-chart').getContext('2d');
    telemetryChart = new Chart(ctx, {
        type: 'line',
        data: {
            labels: [],
            datasets: [{
                label: 'Высота',
                data: [],
                borderColor: 'rgb(75, 192, 192)',
                tension: 0.1,
                yAxisID: 'y'
            }, {
                label: 'Скорость',
                data: [],
                borderColor: 'rgb(255, 99, 132)',
                tension: 0.1,
                yAxisID: 'y1'
            }, {
                label: 'Батарея',
                data: [],
                borderColor: 'rgb(255, 205, 86)',
                tension: 0.1,
                yAxisID: 'y'
            }, {
                label: 'Сигнал',
                data: [],
                borderColor: 'rgb(54, 162, 235)',
                tension: 0.1,
                yAxisID: 'y1'
            }]
        },
        options: {
            responsive: true,
            interaction: {
                mode: 'index', // Включаем взаимодействие по индексу для тултипов
                intersect: false,
            },
            stacked: false, // Отключаем стекинг для независимых осей
            scales: {
                y: {
                    type: 'linear',
                    display: true,
                    position: 'left',
                    beginAtZero: true,
                    title: {
                        display: true,
                        text: 'Высота (м) / Батарея (%)'
                    }
                },
                y1: {
                    type: 'linear',
                    display: true,
                    position: 'right',
                    beginAtZero: true,
                    title: {
                        display: true,
                        text: 'Скорость (м/с) / Сигнал (%)'
                    },
                    grid: {
                        drawOnChartArea: false, // Не рисуем сетку для правой оси
                    }
                }
            },
            plugins: {
                title: {
                    display: true,
                    text: 'Телеметрия выбранного дрона'
                }
            }
        }
    });
}

// Функция для выбора дрона и загрузки его истории телеметрии
async function selectDrone(droneId) {
    selectedDrone = droneId;
    console.log(`Выбран дрон: ${selectedDrone}`);
    // Обновляем заголовок графика
    if (telemetryChart && telemetryChart.options.plugins.title) {
        telemetryChart.options.plugins.title.text = `Телеметрия дрона: ${selectedDrone}`;
        telemetryChart.update();
    }

    // Загружаем историю телеметрии для выбранного дрона
    await loadTelemetryHistory(droneId);
}

// Функция для загрузки истории телеметрии с бэкенда
async function loadTelemetryHistory(droneId) {
    try {
        const response = await fetch(`/api/analytics/history/${droneId}`);
        if (!response.ok) {
            if (response.status === 404) {
                console.warn(`История телеметрии для дрона ${droneId} не найдена.`);
                updateTelemetryChart([]); // Очищаем график
                return;
            }
            throw new Error(`HTTP error! status: ${response.status}`);
        }
        const history = await response.json();
        console.log(`Загружена история телеметрии для ${droneId}: `, history);
        updateTelemetryChart(history); // Обновляем график с полученными данными
    } catch (error) {
        console.error(`Ошибка при загрузке истории телеметрии для ${droneId}:`, error);
        updateTelemetryChart([]); // Очищаем график в случае ошибки
    }
}

// Функция для обновления данных на графике телеметрии
function updateTelemetryChart(history) {
    if (!telemetryChart) return;

    const labels = [];
    const altitudeData = [];
    const speedData = [];
    const batteryData = [];
    const signalData = [];

    history.forEach(point => {
        const date = new Date(point.timestamp);
        labels.push(date.toLocaleTimeString()); // Используем только время для меток
        altitudeData.push(point.altitude);
        speedData.push(point.speed);
        batteryData.push(point.battery);
        signalData.push(point.signal_strength);
    });

    telemetryChart.data.labels = labels;
    telemetryChart.data.datasets[0].data = altitudeData;
    telemetryChart.data.datasets[1].data = speedData;
    telemetryChart.data.datasets[2].data = batteryData;
    telemetryChart.data.datasets[3].data = signalData;
    telemetryChart.update();
}

// Функция для обновления списка потоков (адаптирована для использования данных монитора)
async function updateStreamsList(streams) {
    const streamsListDiv = document.getElementById('streamsList');
    const parentContainer = streamsListDiv.parentElement;
    
    // Создаем или находим контейнер для уведомлений
    let notificationsContainer = parentContainer.querySelector('.notifications-container');
    if (!notificationsContainer) {
        notificationsContainer = document.createElement('div');
        notificationsContainer.className = 'notifications-container';
        parentContainer.insertBefore(notificationsContainer, streamsListDiv);
    }
    
    streamsListDiv.innerHTML = '';

    if (streams.length === 0) {
        streamsListDiv.innerHTML = '<p class="text-muted text-center">Активных потоков нет.</p>';
        return;
    }

    streams.sort((a, b) => a.stream_key.localeCompare(b.stream_key));

    for (const stream of streams) {
        const streamElement = document.createElement('div');
        streamElement.classList.add('stream-item');
        streamElement.innerHTML = `
            <div class="stream-info">
                <h3>
                    <i class="fas fa-drone"></i>
                    Дрон: ${stream.stream_key}
                </h3>
                <p>
                </p>
                <p><i class="fas fa-video"></i> RTMP: ${stream.rtmp_url}</p>
                <p><i class="fas fa-broadcast-tower"></i> RTSP: ${stream.rtsp_url}</p>
                ${stream.hls_url ? `<p><i class="fas fa-play-circle"></i> HLS: <a href="${stream.hls_url}" target="_blank">${stream.hls_url}</a></p>` : ''}
            </div>
            <div class="stream-actions">
                <button type="button" class="btn-action btn-graph" data-drone-id="${stream.stream_key}" title="Показать график">
                    <i class="fas fa-chart-line"></i>
                    График
                </button>
                <button type="button" class="btn-action btn-delete" data-stream-key="${stream.stream_key}" title="Удалить дрон">
                    <i class="fas fa-trash"></i>
                    Удалить
                </button>
            </div>
        `;
        streamsListDiv.appendChild(streamElement);
    }
    
    // Добавляем обработчики клика для кнопок "График"
    streamsListDiv.querySelectorAll('.btn-graph').forEach(button => {
        button.addEventListener('click', (event) => {
            const droneId = event.currentTarget.dataset.droneId;
            selectDrone(droneId);
            // Прокручиваем к графику
            document.querySelector('#telemetry-chart').scrollIntoView({ behavior: 'smooth' });
        });
    });
    
    // Добавляем обработчики клика для кнопок "Удалить"
    streamsListDiv.querySelectorAll('.btn-delete').forEach(button => {
        button.addEventListener('click', async (event) => {
            const streamKeyToDelete = event.currentTarget.dataset.streamKey;
            if (confirm(`Вы уверены, что хотите удалить дрон ${streamKeyToDelete}?`)) {
                try {
                    const response = await fetch(`/api/streams/${streamKeyToDelete}`, {
                        method: 'DELETE'
                    });
                    
                    if (!response.ok) {
                        throw new Error(`Ошибка при удалении: ${response.status}`);
                    }
                    
                    // Удаляем маркер с карты
                    if (markers[streamKeyToDelete]) {
                        map.removeLayer(markers[streamKeyToDelete]);
                        delete markers[streamKeyToDelete];
                    }
                    
                    // Обновляем список потоков
                    await fetchDataAndUpdateUI();
                    
                    // Показываем уведомление об успешном удалении
                    const notification = document.createElement('div');
                    notification.className = 'alert alert-success alert-dismissible fade show';
                    notification.innerHTML = `
                        Дрон ${streamKeyToDelete} успешно удален
                        <button type="button" class="btn-close" data-bs-dismiss="alert"></button>
                    `;
                    
                    // Добавляем уведомление в контейнер
                    notificationsContainer.appendChild(notification);
                    
                    // Удаляем уведомление через 3 секунды
                    setTimeout(() => {
                        notification.remove();
                        // Если контейнер пуст, удаляем его
                        if (notificationsContainer.children.length === 0) {
                            notificationsContainer.remove();
                        }
                    }, 3000);
                    
                } catch (error) {
                    console.error('Ошибка при удалении дрона:', error);
                    alert(`Не удалось удалить дрон: ${error.message}`);
                }
            }
        });
    });
}

// Главная функция для получения данных и обновления UI
async function fetchDataAndUpdateUI() {
    try {
        // Получаем список потоков из API
        const streamsResponse = await fetch('/api/streams');
        if (!streamsResponse.ok) throw new Error(`HTTP error! status: ${streamsResponse.status}`);
        const streamsData = await streamsResponse.json();
        lastStreams = streamsData;
        console.log('Получены данные потоков:', streamsData);
        
        // Обновляем список потоков на странице
        updateStreamsList(streamsData);

        // Получаем текущую телеметрию всех дронов
        const telemetryResponse = await fetch('/api/telemetry');
        if (!telemetryResponse.ok) throw new Error(`HTTP error! status: ${telemetryResponse.status}`);
        const telemetryData = await telemetryResponse.json();
        console.log('Получены данные телеметрии:', telemetryData);

        // Обновляем маркеры на карте
        updateMarkers(telemetryData);

        // Если выбран какой-то дрон, обновляем его график истории (получаем последние данные)
        // Если нужно получать real-time обновления графика, можно использовать WebSocket или другой механизм
        // Для простоты пока просто перезагружаем историю для выбранного дрона
        if (selectedDrone) {
            await loadTelemetryHistory(selectedDrone); // Загружаем последние 100 точек истории
        }

    } catch (error) {
        console.error('Ошибка при получении данных:', error);
        // Можно отобразить сообщение об ошибке на странице
    }
}

// Обновление данных каждые несколько секунд
setInterval(fetchDataAndUpdateUI, 3000); // Обновляем данные каждые 3 секунды

// Инициализация при загрузке страницы
document.addEventListener('DOMContentLoaded', () => {
    initMap();
    initTelemetryChart();
    fetchDataAndUpdateUI(); // Первичная загрузка данных
});

// Вспомогательная функция для копирования RTMP URL (из модального окна)
function copyRtmpUrl(event) {
    const rtmpUrlInput = document.getElementById('rtmpUrl');
    const streamKeyInput = document.getElementById('streamKey');
    const fullRtmpUrl = rtmpUrlInput.value + streamKeyInput.value;
    navigator.clipboard.writeText(fullRtmpUrl).then(() => {
        console.log('RTMP URL скопирован в буфер обмена: ' + fullRtmpUrl);
        // Можно добавить визуальный фидбек для пользователя
        const button = event.target.closest('button');
        if (button) {
            button.innerHTML = '<i class="fas fa-check"></i>'; // Заменяем иконку на галочку
            setTimeout(() => {
                button.innerHTML = '<i class="fas fa-copy"></i>'; // Возвращаем исходную иконку через 2 секунды
            }, 2000);
        }
    }).catch(err => {
        console.error('Не удалось скопировать RTMP URL: ', err);
        // Можно отобразить сообщение об ошибке
    });
}

// RTMP Симулятор Логика (из модального окна)
document.getElementById('videoFile').addEventListener('change', (event) => {
    videoFile = event.target.files[0];
    if (videoFile) {
        const videoElement = document.getElementById('previewVideo');
        videoElement.src = URL.createObjectURL(videoFile);
        videoElement.style.display = 'block'; // Показываем предпросмотр
    }
});

document.getElementById('startStreamBtn').addEventListener('click', async () => {
    const streamKey = document.getElementById('streamKey').value;
    const streamStatusDiv = document.getElementById('streamStatus');
    const startBtn = document.getElementById('startStreamBtn');
    const stopBtn = document.getElementById('stopStreamBtn');
    
    if (!streamKey) {
        alert('Введите ключ потока.');
        return;
    }

    if (!videoFile) {
        alert('Выберите видеофайл для трансляции.');
        return;
    }

    // Отключаем кнопку и показываем статус
    startBtn.disabled = true;
    streamStatusDiv.classList.remove('alert-success', 'alert-danger');
    streamStatusDiv.classList.add('alert-info');
    streamStatusDiv.innerText = 'Подключение...';

    try {
        // Сначала загружаем файл на сервер
        const formData = new FormData();
        formData.append('file', videoFile);
        
        streamStatusDiv.innerText = 'Загрузка файла на сервер...';
        const uploadResponse = await fetch('/api/upload_video/', {
            method: 'POST',
            body: formData
        });
        
        if (!uploadResponse.ok) {
            const errorText = await uploadResponse.text();
            throw new Error(`Ошибка загрузки файла: ${uploadResponse.status} - ${errorText}`);
        }
        
        const uploadResult = await uploadResponse.json();
        console.log('Файл загружен:', uploadResult);
        streamStatusDiv.innerText = 'Файл загружен. Настройка потока...';

        // Добавляем/обновляем поток в MediaMTX через API
        const addStreamResponse = await fetch('/api/streams', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'Accept': 'application/json'
            },
            body: JSON.stringify({
                stream_key: streamKey,
                source_type: 'file',
                file_path: uploadResult.file_path
            })
        });
        
        if (!addStreamResponse.ok) {
            const errorText = await addStreamResponse.text();
            throw new Error(`Ошибка настройки потока в MediaMTX: ${addStreamResponse.status} - ${errorText}`);
        }
        console.log(`Поток ${streamKey} настроен в MediaMTX.`);

        // Устанавливаем WebSocket соединение
        wsConnection = new WebSocket(`ws://${window.location.host}/api/ws/${streamKey}`);

        wsConnection.onopen = () => {
            console.log('WebSocket соединение установлено.');
            streamStatusDiv.classList.remove('alert-info');
            streamStatusDiv.classList.add('alert-success');
            streamStatusDiv.innerText = 'WebSocket подключен. Запуск FFmpeg...';
            
            // Отправляем информацию о файле через WebSocket
            wsConnection.send(JSON.stringify({
                sourceType: 'file',
                filePath: uploadResult.file_path,
                loopFile: true
            }));
            
            startBtn.style.display = 'none';
            stopBtn.style.display = 'inline-block';
            startBtn.disabled = false;
            
            // Добавляем начальную телеметрию для нового потока
            const initialTelemetry = {
                [streamKey]: {
                    latitude: 43.238949,
                    longitude: 76.889709,
                    altitude: 0,
                    speed: 0,
                    battery: 100,
                    signal_strength: 100,
                    status: 'pending'
                }
            };
            
            // Обновляем маркеры на карте с начальной телеметрией
            updateMarkers(initialTelemetry);
            
            // Запускаем периодическое обновление телеметрии для нового потока
            const telemetryInterval = setInterval(async () => {
                try {
                    const response = await fetch('/api/telemetry');
                    if (response.ok) {
                        const telemetryData = await response.json();
                        if (telemetryData[streamKey]) {
                            // Обновляем статус в зависимости от состояния потока
                            if (streamStatusDiv.innerText.includes('активна')) {
                                telemetryData[streamKey].status = 'active';
                            } else if (streamStatusDiv.innerText.includes('ошибка')) {
                                telemetryData[streamKey].status = 'error';
                            }
                            
                            // Добавляем случайное движение для симуляции полета
                            if (telemetryData[streamKey].status === 'active') {
                                const randomLat = telemetryData[streamKey].latitude + (Math.random() - 0.5) * 0.001;
                                const randomLon = telemetryData[streamKey].longitude + (Math.random() - 0.5) * 0.001;
                                telemetryData[streamKey].latitude = randomLat;
                                telemetryData[streamKey].longitude = randomLon;
                                telemetryData[streamKey].altitude = Math.max(0, telemetryData[streamKey].altitude + (Math.random() - 0.5) * 2);
                                telemetryData[streamKey].speed = Math.max(0, telemetryData[streamKey].speed + (Math.random() - 0.5) * 0.5);
                                telemetryData[streamKey].battery = Math.max(0, telemetryData[streamKey].battery - 0.1);
                                telemetryData[streamKey].signal_strength = Math.max(0, telemetryData[streamKey].signal_strength + (Math.random() - 0.5) * 2);
                            }
                            
                            updateMarkers(telemetryData);
                        } else {
                            console.warn(`Телеметрия для потока ${streamKey} не найдена`);
                        }
                    } else {
                        console.error('Ошибка при получении телеметрии:', response.status);
                    }
                } catch (error) {
                    console.error('Ошибка при обновлении телеметрии:', error);
                }
            }, 1000);
            
            // Сохраняем интервал для очистки при остановке
            wsConnection.telemetryInterval = telemetryInterval;
            
            fetchDataAndUpdateUI();
        };

        wsConnection.onmessage = (event) => {
            const data = JSON.parse(event.data);
            console.log('WebSocket получил сообщение:', data);
            streamStatusDiv.classList.remove('alert-info', 'alert-success', 'alert-danger');

            if (data.status === 'active') {
                streamStatusDiv.classList.add('alert-success');
                streamStatusDiv.innerText = 'Трансляция активна';
            } else if (data.status === 'error') {
                streamStatusDiv.classList.add('alert-danger');
                streamStatusDiv.innerText = `Ошибка трансляции: ${data.message}`;
                stopStream(); // Останавливаем соединение и FFmpeg
            } else if (data.status === 'completed') {
                streamStatusDiv.classList.add('alert-info');
                streamStatusDiv.innerText = 'Трансляция завершена.';
                stopStream(); // Останавливаем соединение и FFmpeg
            } else if (data.status === 'pending') {
                streamStatusDiv.classList.add('alert-info');
                streamStatusDiv.innerText = `Статус: ${data.message}`;
            }
            fetchDataAndUpdateUI(); // Обновляем список потоков
        };

        wsConnection.onerror = (error) => {
            console.error('WebSocket ошибка:', error);
            streamStatusDiv.classList.remove('alert-info', 'alert-success');
            streamStatusDiv.classList.add('alert-danger');
            streamStatusDiv.innerText = `Ошибка WebSocket: ${error.message || JSON.stringify(error)}`;
            stopStream(); // Останавливаем соединение и FFmpeg
            fetchDataAndUpdateUI(); // Обновляем список потоков
        };

        wsConnection.onclose = (event) => {
            console.log('WebSocket соединение закрыто:', event);
            // Если соединение закрылось не по нашей инициативе и не из-за ошибки
            if (!event.wasClean && event.code !== 1000) {
                console.warn('WebSocket соединение закрыто с ошибкой или неожиданно.');
                streamStatusDiv.classList.remove('alert-info', 'alert-success');
                streamStatusDiv.classList.add('alert-danger');
                streamStatusDiv.innerText = `WebSocket соединение закрыто. Код: ${event.code}, Причина: ${event.reason || 'неизвестно'}`;
            } else if (event.code === 1000) {
                console.log('WebSocket соединение закрыто чисто.');
            }
            // Если кнопка стоп не была нажата нами, но поток завершился (например, файл закончился)
            if(stopBtn.style.display !== 'none' && streamStatusDiv.innerText.indexOf('Трансляция завершена.') === -1) {
                // Поток завершился неожиданно
                streamStatusDiv.classList.remove('alert-info', 'alert-success');
                streamStatusDiv.classList.add('alert-danger');
                streamStatusDiv.innerText = `Трансляция завершена неожиданно. Код: ${event.code}`;
            }

            startBtn.style.display = 'inline-block';
            stopBtn.style.display = 'none';
            startBtn.disabled = false; // Снова включаем кнопку старт
            fetchDataAndUpdateUI(); // Обновляем список потоков
        };

    } catch (error) {
        console.error('Ошибка при запуске трансляции:', error);
        streamStatusDiv.classList.remove('alert-info', 'alert-success');
        streamStatusDiv.classList.add('alert-danger');
        streamStatusDiv.innerText = `Ошибка: ${error.message}`;
        startBtn.disabled = false;
        fetchDataAndUpdateUI(); // Обновляем список потоков
    }
});

document.getElementById('stopStreamBtn').addEventListener('click', () => {
    stopStream();
});

function stopStream() {
    const streamStatusDiv = document.getElementById('streamStatus');
    const startBtn = document.getElementById('startStreamBtn');
    const stopBtn = document.getElementById('stopStreamBtn');

    if (wsConnection) {
        // Очищаем интервал обновления телеметрии
        if (wsConnection.telemetryInterval) {
            clearInterval(wsConnection.telemetryInterval);
        }
        
        if (wsConnection.readyState === WebSocket.OPEN) {
            console.log('Закрываю WebSocket соединение...');
            wsConnection.close(1000, 'Stream stopped by user');
        }
    }

    // Обновляем UI
    streamStatusDiv.classList.remove('alert-success', 'alert-danger');
    streamStatusDiv.classList.add('alert-info');
    streamStatusDiv.innerText = 'Трансляция остановлена.';

    startBtn.style.display = 'inline-block';
    stopBtn.style.display = 'none';
    startBtn.disabled = false;
    
    // Удаляем маркер с карты
    if (markers[streamKey]) {
        map.removeLayer(markers[streamKey]);
        delete markers[streamKey];
    }
    
    fetchDataAndUpdateUI();
}

var video = document.getElementById('hlsPlayer');
if (Hls.isSupported()) {
  var hls = new Hls();
  hls.loadSource(`http://localhost:8888/${streamKey}`);
  hls.attachMedia(video);
  hls.on(Hls.Events.MANIFEST_PARSED, function() {
    video.play();
  });
} else if (video.canPlayType('application/vnd.apple.mpegurl')) {
  video.src = `http://localhost:8888/${streamKey}`;
  video.addEventListener('loadedmetadata', function() {
    video.play();
  });
}
</script>

<script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>
<link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css" />
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css" />

{% endblock %} 